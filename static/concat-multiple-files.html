<!DOCTYPE html>
<html>

<head>
  <style media="screen">
    body {
      text-align: center;
    }
    video {
      display: block;
      margin: 1em auto;
    }

  </style>
</head>

<body>
  <br>
  <video controls="true" autoplay="true"></video>

  <button type="button">reverse</button>

  <script>
    (async() => {

      const video = document.querySelector("video");

      const urls = [ '1', '3', '4', '5' ].map(n => `https://mediarobotvideo.s3.amazonaws.com/block${n}.webm`);

      function forceArray(thing) {
        if (Array.isArray(thing)) return thing
        return [thing];
      }

      class MediaFile {
        constructor(url, mime, callback) {
          this.url = url
          this.mime = mime || 'video/webm; codecs="vp8"'
          this.duration = null
          this.buffer = null

          this._isReadyPromise = this._setMediaDetails()

          if (callback) this.whenReady(callback)
        }

        async _setBuffer (url) {
          this.buffer = await fetch(url).then(r => r.arrayBuffer())
        }

        whenReady (callback) {
          if (callback) {
            return this._isReadyPromise.then(callback)
          }
          return this._isReadyPromise
        }

        _setDuration() {
          if (!this.buffer) throw new Error('buffer should be set by now')

          return new Promise(resolve => {
            let mediaEl = document.createElement("video")
            mediaEl.onloadedmetadata = (e) => {
              this.duration = mediaEl.duration
              resolve()
            }
            mediaEl.src = URL.createObjectURL(new Blob([this.buffer]));
          })
        }

        async _setMediaDetails () {
          await this._setBuffer(this.url)
          await this._setDuration()
          return this
        }
      }

      class VideoConcatenator {
        constructor (media) {
          this.mediaObjects = [];
          this.addMedia(media)
        }

        getSource(media) {
          if (media) {
            this.replaceMedia(media)
          }
          const ms = this._createMediaSource()
          return URL.createObjectURL(ms)
        }

        replaceMedia(media) {
          this.mediaObjects = [];
          this.addMedia(media);
        }

        addMedia(media) {
          const mediaArray = forceArray(media)
          mediaArray.forEach(m => {
            this.mediaObjects.push(m)
          })
          this.validateMedia()
        }

        validateMedia() {
          const {mime} = this.mediaObjects[0]
          if (this.mediaObjects.every(mo => mo.mime === mime)) return true
          throw new Error('Not all media has the same type')
        }

        _createMediaSource() {
          const mediaSource = new MediaSource()
          const { mediaObjects } = this;
          mediaSource.addEventListener("sourceopen", sourceOpen)

          async function sourceOpen(event) {

            if (MediaSource.isTypeSupported(mediaObjects[0].mime)) {
              const sourceBuffer = mediaSource.addSourceBuffer(mediaObjects[0].mime)

              for (let chunk of mediaObjects) {
                await chunk.whenReady();
                await new Promise(resolve => {
                  sourceBuffer.appendBuffer(chunk.buffer)
                  sourceBuffer.onupdateend = e => {
                    sourceBuffer.onupdateend = null
                    sourceBuffer.timestampOffset += chunk.duration
                    resolve()
                  }
                })

              }

              mediaSource.endOfStream()

            }
            else {
              console.warn(mediaObjects[0].mime + " not supported")
            }
          };

          return mediaSource

        }
      }

      let media = urls.map(url => new MediaFile(url));
      const vc = new VideoConcatenator(media);

      function concatAndLoadMediaIntoPlayer(media) {
        video.src = vc.getSource(media)
      }

      function reverseMedia() {
        media = media.reverse();
        concatAndLoadMediaIntoPlayer(media);
      }

      window.reverseMedia = reverseMedia;

      concatAndLoadMediaIntoPlayer(media);

    })()

    document.querySelector('button').onclick = () => window.reverseMedia();
  </script>


</body>

</html>

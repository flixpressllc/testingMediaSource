<!DOCTYPE html>
<html>

<head>
  <style media="screen">
    body {
      text-align: center;
    }
    video {
      display: block;
      margin: 1em auto;
    }

  </style>
</head>

<body>
  <br>
  <video controls="true" autoplay="true"></video>

  <button type="button">reverse</button>

  <script>
    (async() => {

      const video = document.querySelector("video");

      const urls = [ '1', '3', '4', '5' ].map(n => `https://mediarobotvideo.s3.amazonaws.com/block${n}.webm`);

      function forceArray(thing) {
        if (Array.isArray(thing)) return thing
        return [thing];
      }

      class MediaFile {
        constructor(url, mime, callback) {
          this._url = url
          this.mime = mime || 'video/webm; codecs="vp8"'
          this.isReady = false
          this.duration = null
          this.buffer = null

          this._isReadyPromise = this._getMedia()

          if (callback) this.whenReady(callback)
        }

        _requestFile (url) {
          return fetch(url).then(response => response.arrayBuffer())
        }

        whenReady (callback) {
          if (callback) {
            return this._isReadyPromise.then(callback)
          }
          return this._isReadyPromise
        }

        _getMedia () {
          return new Promise(resolve => {
            let media = document.createElement("video")

            this._requestFile(this._url).then(file => {
              media.onloadedmetadata = (e) => {
                this.duration = media.duration
                this.buffer = file
                this.isReady = true
                resolve(this)
              }
              media.src = URL.createObjectURL(new Blob([file]));
            })
          })
        }
      }

      class VideoConcatenator {
        constructor (media) {
          this.mediaObjects = [];
          this.addMedia(media)
        }

        getSource(media) {
          if (media) {
            this.replaceMedia(media)
          }
          const ms = this._createMediaSource()
          return URL.createObjectURL(ms)
        }

        replaceMedia(media) {
          this.mediaObjects = [];
          this.addMedia(media);
        }

        addMedia(media) {
          const mediaArray = forceArray(media)
          mediaArray.forEach(m => {
            this.mediaObjects.push(m)
          })
        }

        _createMediaSource() {
          const mediaSource = new MediaSource()
          const { mediaObjects } = this;
          mediaSource.addEventListener("sourceopen", sourceOpen)

          async function sourceOpen(event) {

            if (MediaSource.isTypeSupported(mediaObjects[0].mime)) {
              const sourceBuffer = mediaSource.addSourceBuffer(mediaObjects[0].mime)

              for (let chunk of mediaObjects) {
                await new Promise(resolve => {
                  sourceBuffer.appendBuffer(chunk.buffer)
                  sourceBuffer.onupdateend = e => {
                    sourceBuffer.onupdateend = null
                    sourceBuffer.timestampOffset += chunk.duration
                    resolve()
                  }
                })

              }

              mediaSource.endOfStream()

            }
            else {
              console.warn(mediaObjects[0].mime + " not supported")
            }
          };

          return mediaSource

        }
      }

      let media = await Promise.all(urls.map(url => new MediaFile(url).whenReady()))
      const vc = new VideoConcatenator(media);

      function concatAndLoadMediaIntoPlayer(media) {
        video.src = vc.getSource(media)
      }

      function reverseMedia() {
        media = media.reverse();
        concatAndLoadMediaIntoPlayer(media);
      }

      window.reverseMedia = reverseMedia;

      concatAndLoadMediaIntoPlayer(media);

    })()

    document.querySelector('button').onclick = () => window.reverseMedia();
  </script>


</body>

</html>

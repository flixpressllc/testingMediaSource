<!DOCTYPE html>
<html>

<head>
  <style media="screen">
    body {
      text-align: center;
    }
    video {
      display: block;
      margin: 1em auto;
    }

  </style>
</head>

<body>
  <br>
  <video controls="true" autoplay="true"></video>

  <button type="button">reverse</button>

  <script>
    (async() => {

      const video = document.querySelector("video");

      // video.oncanplay = e => video.play();

      const urls = [ '1', '3', '4', '5' ].map(n => `https://mediarobotvideo.s3.amazonaws.com/block${n}.webm`);

      const request = url => fetch(url).then(response => response.arrayBuffer());

      // `urls.reverse()` stops at `.currentTime` : `9`
      const files = await Promise.all(urls.map(request));

      /*
       `.webm` files
       Uncaught DOMException: Failed to execute 'appendBuffer' on 'SourceBuffer': This SourceBuffer has been removed from the parent media source.
       Uncaught DOMException: Failed to set the 'timestampOffset' property on 'SourceBuffer': This SourceBuffer has been removed from the parent media source.
      */
      // const mimeCodec = "video/webm; codecs=opus";
      // https://stackoverflow.com/questions/14108536/how-do-i-append-two-video-files-data-to-a-source-buffer-using-media-source-api/
      const mimeCodec = 'video/webm; codecs="vp8"';


      class MediaFile {
        constructor(url, mime, callback) {
          this._url = url
          this._mime = mime | 'video/webm; codecs="vp8"'
          this.isReady = false
          this.mediaDuration = null
          this.mediaBuffer = null

          this._isReadyPromise = this._getMedia()

          if (callback) this.whenReady(callback)
        }

        _requestFile (url) {
          return fetch(url).then(response => response.arrayBuffer())
        }

        whenReady (callback) {
          if (callback) {
            return this._isReadyPromise.then(callback)
          }
          return this._isReadyPromise
        }

        _getMedia () {
          return new Promise(resolve => {
            let media = document.createElement("video")

            this._requestFile(this._url).then(file => {
              media.onloadedmetadata = (e) => {
                this.mediaDuration = media.duration
                this.mediaBuffer = file
                this.isReady = true
                resolve(this)
              }
              media.src = URL.createObjectURL(new Blob([file]));
            })
          })
        }
      }

      let media = await Promise.all(urls.map(file => new MediaFile(file).whenReady()))

      console.log(media);

      function forceArray(thing) {
        if (Array.isArray(thing)) return thing
        return [thing];
      }

      class VideoConcatenator {
        constructor (media) {
          this.mediaObjects = [];
          this.addMedia(media)
        }

        getSource(media) {
          if (media) {
            this.mediaObjects = [];
            this.addMedia(media);
          }
          return this.createMediaSource(this.mediaObjects)
        }

        addMedia(media) {
          const mediaArray = forceArray(media)
          mediaArray.forEach(m => {
            this.mediaObjects.push(m)
          })
        }

        createMediaSource(media) {
          const mediaSource = new MediaSource()
          mediaSource.addEventListener("sourceopen", sourceOpen)

          async function sourceOpen(event) {

            if (MediaSource.isTypeSupported(mimeCodec)) {
              const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec)

              for (let chunk of media) {
                await new Promise(resolve => {
                  sourceBuffer.appendBuffer(chunk.mediaBuffer)
                  sourceBuffer.onupdateend = e => {
                    sourceBuffer.onupdateend = null
                    sourceBuffer.timestampOffset += chunk.mediaDuration
                    console.log(mediaSource.duration)
                    resolve()
                  }
                })

              }

              mediaSource.endOfStream()

            }
            else {
              console.warn(mimeCodec + " not supported")
            }
          };

          return mediaSource

        }
      }

      const vc = new VideoConcatenator(media);

      function concatAndLoadMediaIntoPlayer(media) {
        let ms = vc.getSource(media);
        video.src = URL.createObjectURL(ms);
      }

      function reverseMedia() {
        media = media.reverse();
        concatAndLoadMediaIntoPlayer(media);
      }

      window.reverseMedia = reverseMedia;

      concatAndLoadMediaIntoPlayer(media);

    })()

    document.querySelector('button').onclick = () => window.reverseMedia();
  </script>


</body>

</html>
